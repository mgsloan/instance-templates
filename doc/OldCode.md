TODO: finish this file.

My solution to this is to discourage the usage of implicit instance suppression
and have two different syntactic forms: one for explicit invocation of a
template, and one that is transitional, with kludgy instance suppression.  The
scope of this suppression is limited to the module that they're defined in,
eliminating the <a href="http://lukepalmer.wordpress.com/2009/01/25/a-world-without-orphans/">trickiness of orphans</a>.


Resolving Overlap
-----------------

We can now make instance declarations generate more class instances than
before, which leads to some things to consider:

* The generated instances might conflict with those already defined in the
  module.  This is a good primary mechanism for "opt-ing out" of a particular
  generated instance.  Since this is adding some "spooky action at distance",
  it's reasonable to generate WARNINGs in order to notify the user that
  something unexpected might happen.

  "Hiding" declarations would be a good way to opt out.  These hiding
  declarations could refer to constraint synonyms (which might have been
  generated by other instance templates), in order to succinctly suppress
  a bunch of the generated instances.

  This particular design decision has been much discussed much within the
  context of Superclass Default Instances.  Within that proposal, this is
  called "Option 2", and seems to be the most popular / the consensus.

* The instances a particular module exports is now dependent on the way the
  classes are defined in its imports. This is not as much of an issue as it
  sounds - an instance of `Monad` will still mean we have an instance of
  `Monad` - be it a normal or compound class constraint.

  However, this is an issue when it comes to orphan instances, as identical
  library + client code could have an instance clash, given a different set of
  definitions for the library's dependencies.  I think that this is acceptable,
  as orphan instances are known to be dangerous, and many instance templates
  would not have this sort of behavior.

* The generated instances might conflict with those produced by other template
  invocations.  This is something that we'd quite reasonably want to do, while
  re-working entire hierarchies.  The rest of this section is devoted to this
  issue.

  For example, we could write an instance template for the old version of
  `Applicative`, that generated the new versions of `Functor` and
  `Applicative`.  We could then also write an instance template for `Monad` that
  generated all three.

  The problem with this is that code using the current hierarchy would quite
  often reasonably have instances for all three, so two versions of
  `Applicative` would be generated. So, the question becomes how we can tell
  which definition supersedes, without hackily defining an arbitrary priority
  order.

  A reasonable way to do this is by allowing an instance template that
  generates a subset of another to have priority.  "Subset" here means that all
  of the instances generated by one template overlap with some instance in
  another template (causing those to be suppressed).


"Problems"
----------

* Ideally we'd be able to seamlessly use old code with our new typeclasses, in
  concordance with "Design goal 1" mentioned in the "Other Proposals" section
  of Default Superclass Instances. However, this means that this feature would
  need to only have a LANGUAGE extension option (e.g. -XInstanceTemplates) for
  the modules defining instance templates.

  Are we comfortable changing the meaning of code without additional pragma,
  in the event that the dependencies specify this pragma?  Is there any
  precedent for language extensions doing this?

  [Niklas Broberg's take on this, in the context of superclass default instances]
  (http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg20351.html)

  If ConstraintKinds is used as the mechanism that allows for naming the set
  of derived instances, then this would also mean that -XConstraintKinds would
  need to be implicit in users of instance templates.  This is not so
  disastrous, though - as this could be restricted to usage of constraint
  kinds, and not actual declaration of them / usage of "Constraint".

* One bit of ugliness is that now we can't move an instance declaration that
  is overlapped by an instance template into another file, without having a
  declaration of the form `hiding instance ...` that suppresses the generated
  instance.

    - One alternative is to have instance templates be a part of the exported
      signature, and then later do whole-program instantiation of these
      templates.  This is the same sort of resolution that would need to take
      place for superclass instance defaults to work out while preserving this
      mobility-of-instances property.

    - The difference in behavior found when moving an instance out of a module
      can actually be beneficial - we can use an instance template which
      overlaps with those defined in the module, even if its definition
      doesn't know about them!  All of the generated instances that overlap
      with the ones that already exist will be suppressed.
